{
  "name": "Togi",
  "nodes": [
    {
      "parameters": {},
      "type": "n8n-nodes-base.manualTrigger",
      "typeVersion": 1,
      "position": [
        0,
        0
      ],
      "id": "54084af8-c317-4f04-9463-3dd5e6908e3b",
      "name": "When clicking ‘Test workflow’"
    },
    {
      "parameters": {
        "jsCode": "// SPDX-License-Identifier: MIT\n//\n// Copyright (c) 2025 Togi\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst crypto = require('crypto');\nconst https = require('https');\n\n// The api host url\nconst API_HOST = 'api.togi-app.com';\n\n// Configuration — replace with your actual credentials and optional encryption secret\nconst API_KEY = 'f510b22df974865c826112fd7c7a50c3';\nconst API_PASSWORD = '+V<e(2XIYBa';\n// leave empty if not using encryption\nconst SECRET = 'n0aubnni4EiPZOYvrvyCG5rqHQofe8FjHTOAjt5IOig';\n// Adjust time into the past in milliseconds. The system clock under Windows\n// is sometimes set into the future even after resync. By substracting this\n// variable from the timestamp used for signature creation, an invalid\n// signature can be prevented.\nconst TIMEOFFSET = 1000; \n\n// How long to wait for an answer (in seconds)\nconst MAX_POLL_SECONDS = 20; // e.g. 600 = 10 minutes\n\n// Input data from upstream node\nconst input = $input.first().json;\nconst { title, description, options, priority } = input;\nconst decisionId = Math.floor(Date.now() / 1000).toString();\n\n// Helper: create HMAC-SHA256 signature\nfunction createSignature(password, timestamp) {\n  return crypto\n    .createHmac('sha256', password)\n    .update(timestamp)\n    .digest('base64');\n}\n\n// Helper: encrypt string with AES-256-CBC and return base64(iv + ciphertext)\nfunction encryptAes256Cbc(jsonString, base64Key) {\n  const key = Buffer.from(base64Key, 'base64');\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n  const encrypted = Buffer.concat([cipher.update(jsonString, 'utf8'), cipher.final()]);\n  return Buffer.concat([iv, encrypted]).toString('base64');\n}\n\n// Helper: decrypt base64(iv + ciphertext) with AES-256-CBC\nfunction decryptAes256Cbc(base64Data, base64Key) {\n  const buffer = Buffer.from(base64Data, 'base64');\n  const iv = buffer.slice(0, 16);\n  const ciphertext = buffer.slice(16);\n  const key = Buffer.from(base64Key, 'base64');\n  const decipher = crypto.createDecipheriv('aes-256-cbc', key, iv);\n  const decrypted = Buffer.concat([decipher.update(ciphertext), decipher.final()]);\n  return JSON.parse(decrypted.toString('utf8'));\n}\n\n// Create decision payload (encrypted or plaintext)\nconst decisionPayload = SECRET\n  ? {\n      id: decisionId,\n      decision: encryptAes256Cbc(JSON.stringify({ title, description, options, priority }), SECRET),\n    }\n  : {\n      id: decisionId,\n      decision: { title, description, options, priority },\n    };\n\nconst requestBody = JSON.stringify(decisionPayload);\n\n// Send signed POST request\nfunction postJson(path, body) {\n  const timestamp = (Date.now() - TIMEOFFSET).toString();\n  const signature = createSignature(API_PASSWORD, timestamp);\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(\n      {\n        hostname: API_HOST,\n        path,\n        method: 'POST',\n        headers: {\n          'X-API-Key': API_KEY,\n          'X-Timestamp': timestamp,\n          'X-Signature': signature,\n          'Content-Type': 'application/json',\n          'Content-Length': Buffer.byteLength(body),\n        },\n      },\n      (res) => {\n        let data = '';\n        res.on('data', (chunk) => (data += chunk));\n        res.on('end', () => resolve({ status: res.statusCode, body: data }));\n      }\n    );\n    req.on('error', reject);\n    req.write(body);\n    req.end();\n  });\n}\n\n// Send signed GET request (fresh signature each time)\nfunction getJson(path) {\n  const timestamp = (Date.now() - TIMEOFFSET).toString();\n  const signature = createSignature(API_PASSWORD, timestamp);\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(\n      {\n        hostname: API_HOST,\n        path,\n        method: 'GET',\n        headers: {\n          'X-API-Key': API_KEY,\n          'X-Timestamp': timestamp,\n          'X-Signature': signature,\n        },\n      },\n      (res) => {\n        let data = '';\n        res.on('data', (chunk) => (data += chunk));\n        res.on('end', () => resolve(data));\n      }\n    );\n    req.on('error', reject);\n    req.end();\n  });\n}\n\n// Delete a decision\nfunction deleteDecision(id) {\n  const timestamp = (Date.now() - 1000).toString();\n  const signature = createSignature(API_PASSWORD, timestamp);\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(\n      {\n        hostname: API_HOST,\n        path: `/api/v1/decision/${id}`,\n        method: 'DELETE',\n        headers: {\n          'X-API-Key': API_KEY,\n          'X-Timestamp': timestamp,\n          'X-Signature': signature,\n        },\n      },\n      (res) => {\n        res.on('data', () => {}); // discard response body\n        res.on('end', () => resolve(res.statusCode));\n      }\n    );\n    req.on('error', reject);\n    req.end();\n  });\n}\n\n// Main logic: send decision, poll answer, decrypt if needed\nreturn new Promise(async (resolve, reject) => {\n  try {\n    const postRes = await postJson('/api/v1/decision', requestBody);\n    if (postRes.status !== 202) {\n      return resolve({ json: { status: postRes.status, error: postRes.body } });\n    }\n\n    for (let i = 0; i < MAX_POLL_SECONDS; i++) {\n      await new Promise((r) => setTimeout(r, 1000));\n      const raw = await getJson(`/api/v1/answer/${decisionId}`);\n      if (raw === '[]') continue;\n\n      try {\n        const answerJson = JSON.parse(raw);\n        if (answerJson.was_deleted === 1) {\n          return resolve({ json: { deleted: true } });\n        }\n\n        const result = SECRET\n          ? decryptAes256Cbc(answerJson.answer, SECRET)\n          : answerJson.answer;\n\n        return resolve({ json: result });\n      } catch (err) {\n        return reject(new Error(`Failed to parse or decrypt answer: ${err.message}`));\n      }\n    }\n\n    await deleteDecision(decisionId);\n    return resolve({\n      json: {\n        timeout: true,\n        message: `No answer received after ${MAX_POLL_SECONDS} seconds. Decision deleted.`,\n      },\n    });\n  } catch (err) {\n    return reject(new Error(`Request failed: ${err.message}`));\n  }\n});\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        432,
        0
      ],
      "id": "fe3d418c-7370-44e1-b452-7d94d96ee062",
      "name": "Togi Decision"
    },
    {
      "parameters": {
        "jsCode": "// SPDX-License-Identifier: MIT\n//\n// Copyright (c) 2025 Togi\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n\nconst crypto = require('crypto');\nconst https = require('https');\n\n// The api host url\nconst API_HOST = 'api.togi-app.com';\n\n// Configuration — replace with your actual credentials and optional encryption secret\nconst API_KEY = 'f510b22df974865c826112fd7c7a50c3';\nconst API_PASSWORD = '+V<e(2XIYBa';\n// leave empty if not using encryption\nconst SECRET = 'n0aubnni4EiPZOYvrvyCG5rqHQofe8FjHTOAjt5IOig';\n// Adjust time into the past in milliseconds. The system clock under Windows\n// is sometimes set into the future even after resync. By substracting this\n// variable from the timestamp used for signature creation, an invalid\n// signature can be prevented.\nconst TIMEOFFSET = 1000; \n\n// Input description field\nconst { description } = $input.first().json;\nconst reportId = Math.floor(Date.now() / 1000).toString();\n\n// Helper: create HMAC-SHA256 signature\nfunction createSignature(password, timestamp) {\n  return crypto\n    .createHmac('sha256', password)\n    .update(timestamp)\n    .digest('base64');\n}\n\n// Helper: encrypt string with AES-256-CBC and return base64(iv + ciphertext)\nfunction encryptAes256Cbc(jsonString, base64Key) {\n  const key = Buffer.from(base64Key, 'base64');\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n  const encrypted = Buffer.concat([cipher.update(jsonString, 'utf8'), cipher.final()]);\n  return Buffer.concat([iv, encrypted]).toString('base64');\n}\n\n// Create report payload (encrypted or plaintext)\nconst reportPayload = SECRET\n  ? {\n      id: reportId,\n      report: encryptAes256Cbc(JSON.stringify({ description }), SECRET),\n    }\n  : {\n      id: reportId,\n      report: { description },\n    };\n\nconst requestBody = JSON.stringify(reportPayload);\n\n// HTTPS POST helper\nfunction postJson(path, body) {\n  const timestamp = (Date.now() - TIMEOFFSET).toString();\n  const signature = createSignature(API_PASSWORD, timestamp);\n\n  return new Promise((resolve, reject) => {\n    const req = https.request(\n      {\n        hostname: API_HOST,\n        path,\n        method: 'POST',\n        headers: {\n          'X-API-Key': API_KEY,\n          'X-Timestamp': timestamp,\n          'X-Signature': signature,\n          'Content-Type': 'application/json',\n          'Content-Length': Buffer.byteLength(body),\n        },\n      },\n      (res) => {\n        let data = '';\n        res.on('data', (chunk) => (data += chunk));\n        res.on('end', () => {\n          resolve({ status: res.statusCode, body: data });\n        });\n      }\n    );\n    req.on('error', (err) => reject(new Error(`Request failed: ${err.message}`)));\n    req.write(body);\n    req.end();\n  });\n}\n\n// Execute and return server response\nreturn postJson('/api/v1/report', requestBody)\n  .then((res) => ({\n    json: {\n      status: res.status,\n      response: res.body,\n    },\n  }))\n  .catch((err) => {\n    throw new Error(err.message);\n  });\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        848,
        0
      ],
      "id": "e288c51d-af28-4ba8-81a0-e875bda07bbe",
      "name": "Togi Report"
    },
    {
      "parameters": {
        "jsCode": "return [\n  {\n    json: {\n      \"title\": \"Deploy update?\",\n      \"description\": \"An update is ready.\\nShould we roll it out now?\",\n      \"options\": [\"Yes\", \"No\", \"Schedule\"],\n      \"priority\": \"medium\"\n    }\n  }\n];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        224,
        0
      ],
      "id": "7455caeb-c239-46dc-99c6-5eb24c803463",
      "name": "Create Decision JSON"
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first().json;\n\nconst description = input.answer\n  ? `Selected: ${input.answer}`\n  : 'Decision was deleted.';\n\nreturn {\n  json: {\n    description\n  }\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        640,
        0
      ],
      "id": "af54174c-6c99-49b5-aa4a-6b1b2dedeaee",
      "name": "Create Report JSON"
    }
  ],
  "pinData": {},
  "connections": {
    "When clicking ‘Test workflow’": {
      "main": [
        [
          {
            "node": "Create Decision JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Togi Decision": {
      "main": [
        [
          {
            "node": "Create Report JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Decision JSON": {
      "main": [
        [
          {
            "node": "Togi Decision",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Create Report JSON": {
      "main": [
        [
          {
            "node": "Togi Report",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "f4ef6838-32a9-420b-beea-ee8c3b2055e9",
  "meta": {
    "instanceId": "a15025ec9e2eba9b504789c1c5134adb3161c87f9ee083892f844185475bdaf9"
  },
  "id": "QcKfUD1mowRSaD3c",
  "tags": []
}